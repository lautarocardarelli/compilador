package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.files.IntermediateCodeGenerator;
import lyc.compiler.files.SymbolTableGenerator;
import java.util.Stack;
import java.util.ArrayList;

class Parser;

action code {:
  private IntermediateCodeGenerator icg = IntermediateCodeGenerator.getIcgInstance();
  private SymbolTableGenerator stg = SymbolTableGenerator.getStgInstance();
:};

// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal IDENTIFIER;
terminal INTEGER_CONSTANT;
terminal FLOAT_CONSTANT;
terminal STRING_CONSTANT;
terminal COMA;
terminal PUNTO_COMA;
terminal OPERACION_TIPO;
terminal CORCH_ABIERTO;
terminal CORCH_CERRADO;
terminal LLAVE_ABIERTA;
terminal LLAVE_CERRADA;
terminal MENOR_IG;
terminal MENOR;
terminal MAYOR_IG;
terminal MAYOR;
terminal IGUAL;
terminal DISTINTO;
terminal WHILE;
terminal AND;
terminal OR;
terminal IF;
terminal ELSE;
terminal WRITE;
terminal READ;
terminal NOT;
terminal INIT;
terminal FLOAT;
terminal INT;
terminal STRING;
terminal DO;
terminal CASE;
terminal DEFAULT;
terminal ENDDO;
terminal COMMENT;
terminal PUNTO;
terminal ALLEQUAL;

// Non Terminals
non terminal program;
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condicion;
non terminal rw;
non terminal condiciones;
non terminal comparador;
non terminal operador_logico;
non terminal bloque_inicializacion;
non terminal sentencia_inicializacion;
non terminal tipo_variable;
non terminal casebody;
non terminal condicioncase;
non terminal EqLista;
non terminal ExpLista;
non terminal allEqual;

/* Extra non terminals: Creados para partir regla y poder introducir
   Acciones semanticas
*/
non terminal ifCondicion;
non terminal ifProgram;
non terminal doCaseInit;

// Start Symbol Definition
start with program;

program ::= sentence {: System.out.println("End / Program"); :};
program ::= program sentence {: System.out.println("Program + Sentence"); :};

/* Delete comment */
sentence ::= COMMENT {: System.out.println("Comment"); :};
/* Done */
sentence ::= IDENTIFIER:id ASSIG expression {: System.out.println("IDENTIFIER = expression [ASIGNACION] \n"); icg.insertarEnPolaca(id, "="); :};
sentence ::= INIT LLAVE_ABIERTA bloque_inicializacion LLAVE_CERRADA {: System.out.println("INIT LLAVE_ABIERTA bloque inicializacion LLAVE_CERRADA \n"); :};


ifCondicion ::=  IF OPEN_BRACKET condiciones {: icg.IfCondiciones(); :} CLOSE_BRACKET;
ifProgram ::=  LLAVE_ABIERTA program {: icg.IfPostProgram(); :} LLAVE_CERRADA;
sentence ::= ifCondicion ifProgram {: icg.IfSaltoAlFinal(); System.out.println("IF Sin else \n"); :};
sentence ::= ifCondicion ifProgram ELSE {: icg.IfSaltoElse(); :} LLAVE_ABIERTA program {: icg.IfSaltoAlFinal(); :} LLAVE_CERRADA {: System.out.println("IF con else \n"); :};


sentence ::= WHILE {:icg.WhileInit();:} OPEN_BRACKET condiciones CLOSE_BRACKET LLAVE_ABIERTA {: icg.WhileCondBeforeProgram(); :} program {: icg.WhileGoToEtiq(); icg.WhileCondPostProgram(); :} LLAVE_CERRADA {: System.out.println("WHILE \n"); :};

sentence ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET {: System.out.println("READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET \n"); icg.insertarEnPolaca(id); icg.insertarEnPolaca("READ"); :};
sentence ::= WRITE OPEN_BRACKET factor CLOSE_BRACKET {: System.out.println("WRITE OPEN_BRACKET factor CLOSE_BRACKET \n"); icg.insertarEnPolaca("WRT"); :};

// do case
doCaseInit ::= DO factor {: icg.insertarEnPolaca("@fact", "="); stg.save("ID", "@fact"); :} casebody;
sentence ::= doCaseInit DEFAULT {: icg.insertarEnPolaca("ETIQ_DEFAULT"); :} program {: icg.DoCaseUpdateSaltoFinal(); :} {: icg.insertarEnPolaca("ETIQ_ENDDO"); :} ENDDO {: System.out.println("DO factor recursivos DEFAULT opcional ENDDO \n"); :};
sentence ::= doCaseInit {: icg.DoCaseUpdateSaltoFinal(); :} ENDDO {: icg.insertarEnPolaca("ETIQ_ENDDO"); :} {: System.out.println("DO factor recursivos DEFAULT opcional ENDDO \n"); :};
casebody ::= casebody CASE condicioncase program {: System.out.println("CASE BODY + CASE BODY \n"); icg.DoCaseEndCase(); :};
casebody ::= CASE condicioncase program {: System.out.println("CASE BODY \n "); icg.DoCaseEndCase(); :};

// al equal
sentence ::= allEqual {: System.out.println("All equal ");:};
allEqual ::= ALLEQUAL {:icg.AllEqualInit(); :} OPEN_BRACKET EqLista CLOSE_BRACKET {: icg.AllEqualEnd();:} {: System.out.println("All equal \n"); :};
EqLista ::= EqLista COMA CORCH_ABIERTO ExpLista CORCH_CERRADO {: icg.setAllEqualI(1); :} {: System.out.println("[EqLista] + [EqLista] \n "); :};
EqLista ::= CORCH_ABIERTO ExpLista CORCH_CERRADO {: icg.AllEqualFirstEQLista(); :} {: System.out.println("[EqLista] \n"); :};
ExpLista ::= ExpLista COMA expression {: System.out.println("Exp Lista COMA expresion \n"); icg.AllEqualCalcs(true); :};
ExpLista ::= expression {: System.out.println("Exp Lista \n"); icg.AllEqualCalcs(false); :};

condicioncase ::= IDENTIFIER:id {: icg.insertarEnPolaca("@fact"); stg.save("ID", "@fact"); :} comparador factor {: icg.DoCaseConditions(); System.out.println("CASE condicioncase assignment \n"); :};

expression ::= expression PLUS term {: System.out.println("+ \n"); icg.insertarEnPolaca("+"); :};
expression ::= expression SUB term {: System.out.println("- \n"); icg.insertarEnPolaca("-");:};
expression ::= term {: System.out.println("Expression = Term \n"); :};

bloque_inicializacion ::= bloque_inicializacion sentencia_inicializacion OPERACION_TIPO tipo_variable {: System.out.println("Bloque inicializacion sentencia inicializacion \n"); icg.addTypeToIds();:};
bloque_inicializacion ::= sentencia_inicializacion OPERACION_TIPO tipo_variable {: System.out.println("Bloque inicializacion \n"); icg.addTypeToIds(); :};
sentencia_inicializacion ::= sentencia_inicializacion COMA IDENTIFIER:id {: System.out.println("Sentencia inicializacion COMA identifier" + id + "\n"); icg.pushIdToType(id.toString()); :};
sentencia_inicializacion ::= IDENTIFIER:id {: System.out.println("Sentencia Inicializacion " + id + "\n"); icg.pushIdToType(id.toString());:};

tipo_variable ::= FLOAT {: System.out.println("Variable float \n"); icg.setVariableType("FLAOT");:};
tipo_variable ::= INT {: System.out.println("Variable int \n"); icg.setVariableType("INT");:};
tipo_variable ::= STRING {: System.out.println("Variable string \n"); icg.setVariableType("STRING");:};

condiciones  ::= condicion operador_logico {: icg.insertarComparadores(); :} condicion {: icg.insertarComparadores(); :};
condiciones  ::= condicion {: System.out.println("CONDICION\n"); :};

condicion ::= expression comparador expression {: System.out.println("condicion es: ID comparador constante \n"); :};
condicion ::= NOT expression comparador expression {: System.out.println("condicion es: NOT ID comparador constante \n"); icg.invertCurrentComparador(); :};
condicion ::= allEqual {: icg.insertarEnPolaca("@resul"); stg.save("ID", "@result"); icg.insertarEnPolaca("True"); icg.setComparador("=="); :};

operador_logico ::= AND {: System.out.println("operador_logico es: AND \n"); icg.setOpLogico("AND");:};
operador_logico ::= OR {: System.out.println("operador_logico es: OR \n"); icg.setOpLogico("OR");:};
comparador  ::= MENOR_IG {: System.out.println("comparador es MENOR_IG \n"); icg.setComparador("<=");:};
comparador  ::= MENOR {: System.out.println("comparador es MENOR \n"); icg.setComparador("<");:};
comparador  ::= MAYOR_IG {: System.out.println("comparador es MAYOR_IG \n"); icg.setComparador(">=");:};
comparador  ::= MAYOR {: System.out.println("comparador es MAYOR \n"); icg.setComparador(">");:};
comparador  ::= IGUAL {: System.out.println("comparador es IGUAL \n"); icg.setComparador("==");:};
comparador  ::= DISTINTO {: System.out.println("comparador es DISTINTO \n"); icg.setComparador("!=");:};

term ::= term MULT factor {: System.out.println("*"); icg.insertarEnPolaca("*");:};
term ::= term DIV factor {: System.out.println("/"); icg.insertarEnPolaca("/");:};
term ::= factor {: System.out.println("Term = factor"); :};

/* chequear si existen en tabla de simbolos */
factor ::= IDENTIFIER:id  {: System.out.println("Id: " + id); icg.insertarEnPolaca(id); :};
factor ::= INTEGER_CONSTANT:constant {: System.out.println("Constant Int: " + constant + "\n" ); icg.insertarEnPolaca("_" + constant); :};
factor ::= FLOAT_CONSTANT:constant {: System.out.println("Constant Float: " + constant); icg.insertarEnPolaca("_" + constant); :};
factor ::= STRING_CONSTANT:constant {: System.out.println("Constant STRING: " + constant); icg.insertarEnPolaca("_" + constant); :};
factor ::= OPEN_BRACKET expression CLOSE_BRACKET {: System.out.println("Factor = (Expression) \n"); :};